# 스프링 DB 접근 기술

# 1. H2 데이터 베이스 설치

개발이나 테스트 용도로 가볍고 편리한 DB, 웹 화면 제공

참고!
순수한 JDBC기술 → Jdbc Template → JPA(SQL조차도 개발자들이 직접짜는게 아님, 조회 Query마저 날려줌. 객체를 바로 DB에 Query없이 저장할 수 있음.) → 스프링 데이터 JPA(JPA를 조금 더 편하게 쓸 수 있게 한번 더 감쌈)  

이후부터는 파일로 접근하게 되면 애플리케이션과 웹 콘솔이 충돌이 날 수 있으니 JDBC URL을 바꿔준다. 파일을 직접 접근하는것이 아니라 소켓을 통해서 접근하게 된다

 [https://www.h2database.com/html/download-archive.html](https://www.h2database.com/html/download-archive.html)

위 링크에 들어가 H2를 설치하자. 나는 **1.4.200 버전을 설치 하였다.**

받았다면 압축을 푼 후에

**terminal**에서 `**cd h2 → cd bin →  chmod 755 [h2.sh](http://h2.sh)**` 로 권한을 주고(MacOS)

**`./h2.sh` 로 실행한다.** 

![Untitled](%E1%84%89%E1%85%B3%E1%84%91%E1%85%B3%E1%84%85%E1%85%B5%E1%86%BC%20DB%200b6fe/Untitled.png)

조금 기다리면 위와 같은 웹 페이지가 나온다.

그대로 ‘연결’ 버튼을 누르면 

![Untitled](%E1%84%89%E1%85%B3%E1%84%91%E1%85%B3%E1%84%85%E1%85%B5%E1%86%BC%20DB%200b6fe/Untitled%201.png)

위와 같은 화면이 뜬다! 뒤로가기를 누르면 나갈 수 있다

여기서

- 내 **home**에서(terminal에서 **`cd ~`**)
- ls를 눌러 **test.mv.db 파일이 생성 되었는지 확인해야한다!**

이게 지금 **“파일로"**접근하는 방식인데, 이후부터는 파일로 접근하게 되면 
애플리케이션과 웹 콘솔이 충돌이 날 수 있으니 **JDBC URL을 바꿔준다**. 
**파일을 직접 접근하는것이 아니라 소켓을 통해서 접근하게 된다**

![Untitled](%E1%84%89%E1%85%B3%E1%84%91%E1%85%B3%E1%84%85%E1%85%B5%E1%86%BC%20DB%200b6fe/Untitled%202.png)

**이제 Table을 먼저 만들어보자!**

![Untitled](%E1%84%89%E1%85%B3%E1%84%91%E1%85%B3%E1%84%85%E1%85%B5%E1%86%BC%20DB%200b6fe/Untitled%203.png)

JAVA에서 `Long` 타입이 H2에서는 `bigint`라는 타입으로 사용되고,
**`generated by default as identity` 의 뜻은 identity값 즉, ID값으로 쓰겠다는 뜻이다!**

실행시키면

![Untitled](%E1%84%89%E1%85%B3%E1%84%91%E1%85%B3%E1%84%85%E1%85%B5%E1%86%BC%20DB%200b6fe/Untitled%204.png)

MEMBER table이 잘 생성되었다! 이후부터는 쿼리문이 사용가능하다

![Untitled](%E1%84%89%E1%85%B3%E1%84%91%E1%85%B3%E1%84%85%E1%85%B5%E1%86%BC%20DB%200b6fe/Untitled%205.png)

```sql
insert into member(name) values('spring1')
insert into member(name) values('spring2')

```

으로 넣어주고, **`SELECT * FROM MEMBER` 으로 확인해보면,**

![Untitled](%E1%84%89%E1%85%B3%E1%84%91%E1%85%B3%E1%84%85%E1%85%B5%E1%86%BC%20DB%200b6fe/Untitled%206.png)

잘 저장된 것을 볼 수 있다!

> **terminal은 끄지마세요.... 접근불가가 되니까요.. 
끄면 다시 terminal 실행시키고 켜야합니다!**
> 

# 2. 순수 JDBC 사용해보기

순수 JDBC는 거의 20년전... 고대의 방법이다. 자세히는 기술하지 않겠다. 개념적인 부분만 훑고지나간다!

1. **build.gradle 파일에 jdbc, h2 데이터베이스 관련 라이브러리 추가**

```sql
implementation 'org.springframework.boot:spring-boot-starter-jdbc'
runtimeOnly 'com.h2database:h
```

1. **스프링 부트 데이터베이스 연결 설정 추가**

**resources/application.properties**

```sql
spring.datasource.url=jdbc:h2:tcp://localhost/~/test
spring.datasource.driver-class-name=org.h2.Driver
spring.datasource.username=sa
```

1. **Jdbc 회원 리포지토리**

```sql
package hello.hellospring.repository;
import hello.hellospring.domain.Member;
import org.springframework.jdbc.datasource.DataSourceUtils;
import javax.sql.DataSource;
import java.sql.*;
import java.util.ArrayList;
import java.util.List;
import java.util.Optional;

public class JdbcMemberRepository implements MemberRepository {
 private final DataSource dataSource;
 public JdbcMemberRepository(DataSource dataSource) {
 this.dataSource = dataSource;
 }
 @Override
 public Member save(Member member) {
 String sql = "insert into member(name) values(?)";
 Connection conn = null;
 PreparedStatement pstmt = null;
 ResultSet rs = null;
 try {
 conn = getConnection();
 pstmt = conn.prepareStatement(sql,
Statement.RETURN_GENERATED_KEYS);
 pstmt.setString(1, member.getName());
 pstmt.executeUpdate();
 rs = pstmt.getGeneratedKeys();
 if (rs.next()) {
 member.setId(rs.getLong(1));
 } else {
 throw new SQLException("id 조회 실패");
 }
 return member;
 } catch (Exception e) {
 throw new IllegalStateException(e);
 } finally {
 close(conn, pstmt, rs);
 }
 }
 @Override
 public Optional<Member> findById(Long id) {
 String sql = "select * from member where id = ?";
 Connection conn = null;
 PreparedStatement pstmt = null;
 ResultSet rs = null;
 try {
 conn = getConnection();
 pstmt = conn.prepareStatement(sql);
 pstmt.setLong(1, id);
 rs = pstmt.executeQuery();
 if(rs.next()) {
 Member member = new Member();
 member.setId(rs.getLong("id"));
 member.setName(rs.getString("name"));
 return Optional.of(member);
 } else {
 return Optional.empty();
 }
 } catch (Exception e) {
 throw new IllegalStateException(e);
 } finally {
 close(conn, pstmt, rs);
 }
 }
 @Override
 public List<Member> findAll() {
 String sql = "select * from member";
 Connection conn = null;
 PreparedStatement pstmt = null;
 ResultSet rs = null;
 try {
 conn = getConnection();
 pstmt = conn.prepareStatement(sql);
 rs = pstmt.executeQuery();
 List<Member> members = new ArrayList<>();
 while(rs.next()) {
 Member member = new Member();
 member.setId(rs.getLong("id"));
 member.setName(rs.getString("name"));
 members.add(member);
 }
 return members;
 } catch (Exception e) {
 throw new IllegalStateException(e);
 } finally {
 close(conn, pstmt, rs);
 }
 }
 @Override
 public Optional<Member> findByName(String name) {
 String sql = "select * from member where name = ?";
 Connection conn = null;
 PreparedStatement pstmt = null;
 ResultSet rs = null;
 try {
 conn = getConnection();
 pstmt = conn.prepareStatement(sql);
 pstmt.setString(1, name);
 rs = pstmt.executeQuery();
 if(rs.next()) {
 Member member = new Member();
 member.setId(rs.getLong("id"));
 member.setName(rs.getString("name"));
 return Optional.of(member);
 }
 return Optional.empty();
 } catch (Exception e) {
 throw new IllegalStateException(e);
 } finally {
 close(conn, pstmt, rs);
 }
 }
 private Connection getConnection() {
 return DataSourceUtils.getConnection(dataSource);
 }
 private void close(Connection conn, PreparedStatement pstmt, ResultSet rs)
{
 try {
 if (rs != null) {
 rs.close();
 }
 } catch (SQLException e) {
 e.printStackTrace();
 }
 try {
 if (pstmt != null) {
 pstmt.close();
 }
 } catch (SQLException e) {
 e.printStackTrace();
 }
 try {
 if (conn != null) {
 close(conn);
 }
 } catch (SQLException e) {
 e.printStackTrace();
 }
 }
 private void close(Connection conn) throws SQLException {
 DataSourceUtils.releaseConnection(conn, dataSource);
 }
}
```

**DataSource는 데이터베이스 커넥션을 획득할 때 사용하는 객체**다. 스프링 부트는 데이터베이스 커넥션
정보를 바탕으로 **DataSource를 생성하고 스프링 빈으로 만들어둔다**. 그래서 DI를 받을 수 있다.

Spring을 쓰는 이유 : 객체 지향이 좋다고 하잖아
**다형성 → 인터페이스를 기반으로 구현체를 마음대로 바꿔 낄 수 있다. (스프링 컨테이너가 지원해줌)
과거에는 이런 코드를 하나  바꾸는 순간 다른 코드들도 바꿔줘야 한다.
Application 코드만 손대면 다른건 신경안써도된다.**

즉, Java의 특징으론

**개방-폐쇄 원칙(OCP, Open-Closed Principle)**→확장에는 열려있고, 수정, 변경에는 닫혀있다.
**스프링의 DI (Dependencies Injection)을 사용하면** 기존 코드를 전혀 손대지 않고, 설정만으로 구현
클래스를 변경할 수 있다.
**데이터를 DB에 저장하므로 스프링 서버를 다시 실행해도 데이터가 안전하게 저장된다.**

# 3. 스프링 통합 테스트

DB까지 연결해서 통합 테스트를 해보자.

**회원 서비스 스프링 통합 테스트**

```sql
package hello.hellospring.service;
import hello.hellospring.domain.Member;
import hello.hellospring.repository.MemberRepository;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.transaction.annotation.Transactional;
import static org.assertj.core.api.Assertions.assertThat;
import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertThrows;
@SpringBootTest
@Transactional
class MemberServiceIntegrationTest {
 @Autowired MemberService memberService;
 @Autowired MemberRepository memberRepository;
 @Test
 public void 회원가입() throws Exception {
 //Given
 Member member = new Member();
 member.setName("hello");
 //When
 Long saveId = memberService.join(member);
 //Then
 Member findMember = memberRepository.findById(saveId).get();
 assertEquals(member.getName(), findMember.getName());
 }
 @Test
 public void 중복_회원_예외() throws Exception {
 //Given
 Member member1 = new Member();
 member1.setName("spring");
 Member member2 = new Member();
 member2.setName("spring");
 //When
 memberService.join(member1);
 IllegalStateException e = assertThrows(IllegalStateException.class,
 () -> memberService.join(member2));//예외가 발생해야 한다.
 assertThat(e.getMessage()).isEqualTo("이미 존재하는 회원입니다.");
 }
}
```

**@SpringBootTest** : 스프링 컨테이너와 테스트를 함께 실행한다

**@Transactional** : 테스트 케이스에 이 애노테이션이 있으면, 테스트 시작 전에 트랜잭션을 시작하고,
테스트 완료 후에 항상 롤백한다. 이렇게 하면 DB에 데이터가 남지 않으므로 다음 테스트에 영향을 주지
않는다.

# 4. 스프링 JdbcTemplate

- 설정은 순수 Jdbc와 같이 한다.
- 스프링 JdbcTemplate과 MyBatis 같은 라이브러리는 JDBC API에서 본 반복 코드를 대부분
제거해준다. 하지만 SQL은 직접 작성해야 한다.

**repository에 JdbcTemplateMemberRepository 클래스를 만들자**