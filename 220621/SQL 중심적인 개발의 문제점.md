# SQL 중심적인 개발의 문제점

현대적 애플리케이션 개발시에는 대부분 **객체지향 언어** 씀

그리고 **관계형 DB**(Oracle, MySQL)을 쓸거에요

즉, **객체를 관계형 DB에 저장하여 관리**

DB는 SQL만 알아들으니까 결국 코드 까보면 SQL만 있네...?

1. 무한 반복, 지루한 코드
- CRUD
    - INSERT INTO
    - UPDATE
    - SELECT
    - DELETE …..
- 테이블이 10개면 10번 다해줘야하네…….

객체를 영구 보관하는 다양한 저장소가 있는데,(RDB, NoSQL, file, OODB)

현실적인 대안은 **관계형 DB** 입니다.(RDB)

**객체를 SQL로 바꾸어주어야 관계형 DB에 넣을 수 있어요
→ 이걸 누가해..? 개발자 == SQL매퍼 역할만 하네
출근해서 허구한날 SQL만 짜네….**

근데, 

## 객체 vs 관계형 데이터 베이스의 차이

1. 상속
    - **객체 상속 관계 - Table 슈퍼타입 서브타입 관계**
    
    ![Untitled](SQL%20%E1%84%8C%E1%85%AE%E1%86%BC%E1%84%89%E1%85%B5%E1%86%B7%E1%84%8C%E1%85%A5%E1%86%A8%E1%84%8B%E1%85%B5%E1%86%AB%20%E1%84%80%E1%85%A2%E1%84%87%E1%85%A1%E1%86%AF%E1%84%8B%E1%85%B4%20%E1%84%86%E1%85%AE%E1%86%AB%E1%84%8C%E1%85%A6%E1%84%8C%E1%85%A5%E1%86%B7%201a99e7b8c60d4c0784624d1c975b095f/Untitled.png)
    
    문제는, Album을 하나 넣는다면 객체를 분해→ **INSERT를 ITEM, ALBUM 모두에 써야한다.**
    
    ALBUM 조회 하려면
    
    1. 각각의 테이블에 따른 조인 SQL 작성...
    2. 각각의 객체 생성...
    3. 상상만 해도 복잡
    4. 더 이상의 설명은 생략한다.
    5. 그래서 **DB에 저장할 객체에는 상속 관계 안쓴다**.
    
    **해결방법 → 자바 컬렉션에 저장한다
    저장 - list.add(album);
    조회- Album album = list.get(albumId);
    부모 타입으로 조회, 다형성 - Item item = list.get(albumId);**
    
    쉽죠?
    
2. 연관관계

![Untitled](SQL%20%E1%84%8C%E1%85%AE%E1%86%BC%E1%84%89%E1%85%B5%E1%86%B7%E1%84%8C%E1%85%A5%E1%86%A8%E1%84%8B%E1%85%B5%E1%86%AB%20%E1%84%80%E1%85%A2%E1%84%87%E1%85%A1%E1%86%AF%E1%84%8B%E1%85%B4%20%E1%84%86%E1%85%AE%E1%86%AB%E1%84%8C%E1%85%A6%E1%84%8C%E1%85%A5%E1%86%B7%201a99e7b8c60d4c0784624d1c975b095f/Untitled%201.png)

- 객체는 참조를 사용하기 때문에 Member가 Team을 조회할 수 있지만
- 테이블은 MEMBER, TEAM이 서로를 조회할 수 있다

1. 데이터 타입
- 테이블에 맞춘 객체 저장
2. 데이터 식별 방법

![Untitled](SQL%20%E1%84%8C%E1%85%AE%E1%86%BC%E1%84%89%E1%85%B5%E1%86%B7%E1%84%8C%E1%85%A5%E1%86%A8%E1%84%8B%E1%85%B5%E1%86%AB%20%E1%84%80%E1%85%A2%E1%84%87%E1%85%A1%E1%86%AF%E1%84%8B%E1%85%B4%20%E1%84%86%E1%85%AE%E1%86%AB%E1%84%8C%E1%85%A6%E1%84%8C%E1%85%A5%E1%86%B7%201a99e7b8c60d4c0784624d1c975b095f/Untitled%202.png)

MEMBER과 TEAM을 객체지향처럼 모델링을 하면,
Foreign key가 아니라 객체를 넣어 놓는다
→ 필요할 때마다 .getId() 등등으로 꺼내 쓰면되겠네!

**⇒ 문제점: 조회할때 발생** 

![Untitled](SQL%20%E1%84%8C%E1%85%AE%E1%86%BC%E1%84%89%E1%85%B5%E1%86%B7%E1%84%8C%E1%85%A5%E1%86%A8%E1%84%8B%E1%85%B5%E1%86%AB%20%E1%84%80%E1%85%A2%E1%84%87%E1%85%A1%E1%86%AF%E1%84%8B%E1%85%B4%20%E1%84%86%E1%85%AE%E1%86%AB%E1%84%8C%E1%85%A6%E1%84%8C%E1%85%A5%E1%86%B7%201a99e7b8c60d4c0784624d1c975b095f/Untitled%203.png)

MEMBER, TEAM을 JOIN 한다.
Data를 SQL로 한번에 불러온다.
Data가 Member, team 섞여있을 건데,
거기서 member부분 꺼내고, team 부분 꺼내서 값을 모두 세팅해서 넣고,
개발자가 직접 회원과 팀 관계를 설정해야한다.
⇒ 총평: 귀찮다.

**해결방법: 자바 컬렉션에 관리한다 (이러면 객체 지향으로 하는게 오히려 좋다)**

꺼낼때도 member.getTeam(); 하면 됨.

이렇게 안하고 db에 넣는 순간 개발자는 죽어난다.

생산성이 매우 떨어진다.

![Untitled](SQL%20%E1%84%8C%E1%85%AE%E1%86%BC%E1%84%89%E1%85%B5%E1%86%B7%E1%84%8C%E1%85%A5%E1%86%A8%E1%84%8B%E1%85%B5%E1%86%AB%20%E1%84%80%E1%85%A2%E1%84%87%E1%85%A1%E1%86%AF%E1%84%8B%E1%85%B4%20%E1%84%86%E1%85%AE%E1%86%AB%E1%84%8C%E1%85%A6%E1%84%8C%E1%85%A5%E1%86%B7%201a99e7b8c60d4c0784624d1c975b095f/Untitled%204.png)

![Untitled](SQL%20%E1%84%8C%E1%85%AE%E1%86%BC%E1%84%89%E1%85%B5%E1%86%B7%E1%84%8C%E1%85%A5%E1%86%A8%E1%84%8B%E1%85%B5%E1%86%AB%20%E1%84%80%E1%85%A2%E1%84%87%E1%85%A1%E1%86%AF%E1%84%8B%E1%85%B4%20%E1%84%86%E1%85%AE%E1%86%AB%E1%84%8C%E1%85%A6%E1%84%8C%E1%85%A5%E1%86%B7%201a99e7b8c60d4c0784624d1c975b095f/Untitled%205.png)

→ 처음에 member, team만 갖고 작업하려고 했는데,
중간에 getOrder(); 하면 null 값이 뜨는 이유는
처음에 **Member, Team 만 JOIN 해 놨기 때문에 주문정보에 대한** table 정보가 없기 때문에. member 필드에 order가 있다고 해서 마음대로 order는 꺼낼 수 없는 것.

![Untitled](SQL%20%E1%84%8C%E1%85%AE%E1%86%BC%E1%84%89%E1%85%B5%E1%86%B7%E1%84%8C%E1%85%A5%E1%86%A8%E1%84%8B%E1%85%B5%E1%86%AB%20%E1%84%80%E1%85%A2%E1%84%87%E1%85%A1%E1%86%AF%E1%84%8B%E1%85%B4%20%E1%84%86%E1%85%AE%E1%86%AB%E1%84%8C%E1%85%A6%E1%84%8C%E1%85%A5%E1%86%B7%201a99e7b8c60d4c0784624d1c975b095f/Untitled%206.png)

→ 비즈니스 로직을 남이 개발했다고 가정하자.

봤는데 `Member member` 로 받는다고 하더라도

`member.getTeam();`

`member.getOrder().getDelivery();`

이걸 정말 자유롭게 호출할 수 있을까? → 믿을 수 없다.

`memberDAO`에서 무슨 일이 일어났고 무슨 쿼리가 날아갔는지 직접 확인하기 전까지는 완전 신뢰하면 안된다.

**Layered architecture는 그 다음 계층에서도 신뢰하고 쓸 수 있어야하는데
동료 개발자가 만들어 놓은 Entity가 신뢰가 안되는거야.**

그렇다고, 모든 객체를 미리 로딩할 수는 없잖아.
****

![Untitled](SQL%20%E1%84%8C%E1%85%AE%E1%86%BC%E1%84%89%E1%85%B5%E1%86%B7%E1%84%8C%E1%85%A5%E1%86%A8%E1%84%8B%E1%85%B5%E1%86%AB%20%E1%84%80%E1%85%A2%E1%84%87%E1%85%A1%E1%86%AF%E1%84%8B%E1%85%B4%20%E1%84%86%E1%85%AE%E1%86%AB%E1%84%8C%E1%85%A6%E1%84%8C%E1%85%A5%E1%86%B7%201a99e7b8c60d4c0784624d1c975b095f/Untitled%207.png)

결국,

![Untitled](SQL%20%E1%84%8C%E1%85%AE%E1%86%BC%E1%84%89%E1%85%B5%E1%86%B7%E1%84%8C%E1%85%A5%E1%86%A8%E1%84%8B%E1%85%B5%E1%86%AB%20%E1%84%80%E1%85%A2%E1%84%87%E1%85%A1%E1%86%AF%E1%84%8B%E1%85%B4%20%E1%84%86%E1%85%AE%E1%86%AB%E1%84%8C%E1%85%A6%E1%84%8C%E1%85%A5%E1%86%B7%201a99e7b8c60d4c0784624d1c975b095f/Untitled%208.png)

![Untitled](SQL%20%E1%84%8C%E1%85%AE%E1%86%BC%E1%84%89%E1%85%B5%E1%86%B7%E1%84%8C%E1%85%A5%E1%86%A8%E1%84%8B%E1%85%B5%E1%86%AB%20%E1%84%80%E1%85%A2%E1%84%87%E1%85%A1%E1%86%AF%E1%84%8B%E1%85%B4%20%E1%84%86%E1%85%AE%E1%86%AB%E1%84%8C%E1%85%A6%E1%84%8C%E1%85%A5%E1%86%B7%201a99e7b8c60d4c0784624d1c975b095f/Untitled%209.png)

식별자가 똑같아도 Query 날리고, 또 날리는 과정에서

`new Member()` 로 값을 넣은 후 반환한다.
일반적인 SQL사용하면 member1 ≠ member2가 된다.

![Untitled](SQL%20%E1%84%8C%E1%85%AE%E1%86%BC%E1%84%89%E1%85%B5%E1%86%B7%E1%84%8C%E1%85%A5%E1%86%A8%E1%84%8B%E1%85%B5%E1%86%AB%20%E1%84%80%E1%85%A2%E1%84%87%E1%85%A1%E1%86%AF%E1%84%8B%E1%85%B4%20%E1%84%86%E1%85%AE%E1%86%AB%E1%84%8C%E1%85%A6%E1%84%8C%E1%85%A5%E1%86%B7%201a99e7b8c60d4c0784624d1c975b095f/Untitled%2010.png)

반면, 컬렉션에서 조회시
참조값이 똑같기 때문에 비교를 하면 같다고 나온다.

![Untitled](SQL%20%E1%84%8C%E1%85%AE%E1%86%BC%E1%84%89%E1%85%B5%E1%86%B7%E1%84%8C%E1%85%A5%E1%86%A8%E1%84%8B%E1%85%B5%E1%86%AB%20%E1%84%80%E1%85%A2%E1%84%87%E1%85%A1%E1%86%AF%E1%84%8B%E1%85%B4%20%E1%84%86%E1%85%AE%E1%86%AB%E1%84%8C%E1%85%A6%E1%84%8C%E1%85%A5%E1%86%B7%201a99e7b8c60d4c0784624d1c975b095f/Untitled%2011.png)

![Untitled](SQL%20%E1%84%8C%E1%85%AE%E1%86%BC%E1%84%89%E1%85%B5%E1%86%B7%E1%84%8C%E1%85%A5%E1%86%A8%E1%84%8B%E1%85%B5%E1%86%AB%20%E1%84%80%E1%85%A2%E1%84%87%E1%85%A1%E1%86%AF%E1%84%8B%E1%85%B4%20%E1%84%86%E1%85%AE%E1%86%AB%E1%84%8C%E1%85%A6%E1%84%8C%E1%85%A5%E1%86%B7%201a99e7b8c60d4c0784624d1c975b095f/Untitled%2012.png)

## 답은 JPA에 있다