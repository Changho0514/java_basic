# 주문 조회 V3.1: 엔티티를 DTO로 변환 - 페이징과 한계 돌파

## 컬렉션을 페치 조인하면 페이징이 불가능하다.

- 컬렉션을 페치 조인하면 일대다 조인이 발생하므로 데이터가 예측할 수 없이 증가한다.
- **`일다대에서 일(1)을 기준으로 페이징을 하는 것이 목적`**이다. **그런데 데이터는 다(N)를 기준으로 row가 생성된다.**
- **Order를 기준으로 페이징 하고 싶은데, 다(N)인 OrderItem을 조인하면 OrderItem이 기준이되어버린다.**
(더 자세한 내용은 자바 ORM 표준 JPA 프로그래밍 - 페치 조인 한계 참조)
- 이 경우 하이버네이트는 경고 로그를 남기고 모든 DB 데이터를 읽어서 메모리에서 페이징을 시도한다. 최악의 경우 장애로 이어질 수 있다.

## **한계 돌파**

### 그러면 페이징 + 컬렉션 엔티티를 함께 조회하려면 어떻게 해야할까?

**지금부터 코드도 단순하고, 성능 최적화도 보장하는 매우 강력한 방법을 소개하겠다. 대부분의 페이징 + 컬렉션 엔티티 조회 문제는 이 방법으로 해결할 수 있다.**

1. **먼저 ToOne(OneToOne, ManyToOne) 관계를 모두 페치조인** 한다. 
**ToOne 관계는 row수를 증가시키지 않으므로 페이징 쿼리에 영향을 주지 않는다**

1. 컬렉션은 지연 로딩으로 조회한다.
지연 로딩 성능 최적화를 위해 `hibernate.default_batch_fetch_size , @BatchSize` 를 적용한다.
2. **hibernate.default_batch_fetch_size**`:` 글로벌 설정
**@BatchSize**: 개별 최적화
이 옵션을 사용하면 컬렉션이나, 프록시 객체를 한꺼번에 설정한 size 만큼 IN 쿼리로 조회한다.

## 코드

**delivery, member는 row를 바꾸지 않는다.**

![Untitled](%E1%84%8C%E1%85%AE%E1%84%86%E1%85%AE%E1%86%AB%20%E1%84%8C%E1%85%A9%E1%84%92%E1%85%AC%20V3%201%20%E1%84%8B%E1%85%A6%E1%86%AB%E1%84%90%E1%85%B5%E1%84%90%E1%85%B5%E1%84%85%E1%85%B3%E1%86%AF%20DTO%E1%84%85%E1%85%A9%20%E1%84%87%E1%85%A7%E1%86%AB%E1%84%92%E1%85%AA%E1%86%AB%20-%20%E1%84%91%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%8C%E1%85%B5%E1%86%BC%E1%84%80%20d93f4fc8ab224315b449f16fe9defa8d/Untitled.png)

**근데 이렇게 하면 orderItems가 해결이 안되어 N+1 문제가 터질 것이다.**

우선 실행시켜보면,

![Untitled](%E1%84%8C%E1%85%AE%E1%84%86%E1%85%AE%E1%86%AB%20%E1%84%8C%E1%85%A9%E1%84%92%E1%85%AC%20V3%201%20%E1%84%8B%E1%85%A6%E1%86%AB%E1%84%90%E1%85%B5%E1%84%90%E1%85%B5%E1%84%85%E1%85%B3%E1%86%AF%20DTO%E1%84%85%E1%85%A9%20%E1%84%87%E1%85%A7%E1%86%AB%E1%84%92%E1%85%AA%E1%86%AB%20-%20%E1%84%91%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%8C%E1%85%B5%E1%86%BC%E1%84%80%20d93f4fc8ab224315b449f16fe9defa8d/Untitled%201.png)

- 첫 쿼리는 `member`와 `delivery`를 fetch join 으로 가져옴.
이친구들은 `ToOne` 관계에 있으니까.

`orderItem`은 해결이 안됐는데?
`OrderDto`는 루프를 돌면서 orderItems를 꺼내와야하니까

![Untitled](%E1%84%8C%E1%85%AE%E1%84%86%E1%85%AE%E1%86%AB%20%E1%84%8C%E1%85%A9%E1%84%92%E1%85%AC%20V3%201%20%E1%84%8B%E1%85%A6%E1%86%AB%E1%84%90%E1%85%B5%E1%84%90%E1%85%B5%E1%84%85%E1%85%B3%E1%86%AF%20DTO%E1%84%85%E1%85%A9%20%E1%84%87%E1%85%A7%E1%86%AB%E1%84%92%E1%85%AA%E1%86%AB%20-%20%E1%84%91%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%8C%E1%85%B5%E1%86%BC%E1%84%80%20d93f4fc8ab224315b449f16fe9defa8d/Untitled%202.png)

쿼리가 따로 나간다

![Untitled](%E1%84%8C%E1%85%AE%E1%84%86%E1%85%AE%E1%86%AB%20%E1%84%8C%E1%85%A9%E1%84%92%E1%85%AC%20V3%201%20%E1%84%8B%E1%85%A6%E1%86%AB%E1%84%90%E1%85%B5%E1%84%90%E1%85%B5%E1%84%85%E1%85%B3%E1%86%AF%20DTO%E1%84%85%E1%85%A9%20%E1%84%87%E1%85%A7%E1%86%AB%E1%84%92%E1%85%AA%E1%86%AB%20-%20%E1%84%91%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%8C%E1%85%B5%E1%86%BC%E1%84%80%20d93f4fc8ab224315b449f16fe9defa8d/Untitled%203.png)

근데, orderItem 하나당 item 두개를 갖고있다.

![Untitled](%E1%84%8C%E1%85%AE%E1%84%86%E1%85%AE%E1%86%AB%20%E1%84%8C%E1%85%A9%E1%84%92%E1%85%AC%20V3%201%20%E1%84%8B%E1%85%A6%E1%86%AB%E1%84%90%E1%85%B5%E1%84%90%E1%85%B5%E1%84%85%E1%85%B3%E1%86%AF%20DTO%E1%84%85%E1%85%A9%20%E1%84%87%E1%85%A7%E1%86%AB%E1%84%92%E1%85%AA%E1%86%AB%20-%20%E1%84%91%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%8C%E1%85%B5%E1%86%BC%E1%84%80%20d93f4fc8ab224315b449f16fe9defa8d/Untitled%204.png)

![Untitled](%E1%84%8C%E1%85%AE%E1%84%86%E1%85%AE%E1%86%AB%20%E1%84%8C%E1%85%A9%E1%84%92%E1%85%AC%20V3%201%20%E1%84%8B%E1%85%A6%E1%86%AB%E1%84%90%E1%85%B5%E1%84%90%E1%85%B5%E1%84%85%E1%85%B3%E1%86%AF%20DTO%E1%84%85%E1%85%A9%20%E1%84%87%E1%85%A7%E1%86%AB%E1%84%92%E1%85%AA%E1%86%AB%20-%20%E1%84%91%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%8C%E1%85%B5%E1%86%BC%E1%84%80%20d93f4fc8ab224315b449f16fe9defa8d/Untitled%205.png)

쿼리가 2개 나간다.
**N+1이 터지게 됨**

OrderItem 컬렉션은 엔티티상 OrderItem 2개 들어있음
그리고 그 안에는 또 Item 2개가 들어가있음.

![Untitled](%E1%84%8C%E1%85%AE%E1%84%86%E1%85%AE%E1%86%AB%20%E1%84%8C%E1%85%A9%E1%84%92%E1%85%AC%20V3%201%20%E1%84%8B%E1%85%A6%E1%86%AB%E1%84%90%E1%85%B5%E1%84%90%E1%85%B5%E1%84%85%E1%85%B3%E1%86%AF%20DTO%E1%84%85%E1%85%A9%20%E1%84%87%E1%85%A7%E1%86%AB%E1%84%92%E1%85%AA%E1%86%AB%20-%20%E1%84%91%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%8C%E1%85%B5%E1%86%BC%E1%84%80%20d93f4fc8ab224315b449f16fe9defa8d/Untitled%206.png)

쿼리가 총 7번 실행되는구나..

`offset, limit` 파라미터를 설정하고, 

![Untitled](%E1%84%8C%E1%85%AE%E1%84%86%E1%85%AE%E1%86%AB%20%E1%84%8C%E1%85%A9%E1%84%92%E1%85%AC%20V3%201%20%E1%84%8B%E1%85%A6%E1%86%AB%E1%84%90%E1%85%B5%E1%84%90%E1%85%B5%E1%84%85%E1%85%B3%E1%86%AF%20DTO%E1%84%85%E1%85%A9%20%E1%84%87%E1%85%A7%E1%86%AB%E1%84%92%E1%85%AA%E1%86%AB%20-%20%E1%84%91%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%8C%E1%85%B5%E1%86%BC%E1%84%80%20d93f4fc8ab224315b449f16fe9defa8d/Untitled%207.png)

`application.yml` 에 `hibernate.default_batch_fetch_size` 를 한번 넣어보자.

![Untitled](%E1%84%8C%E1%85%AE%E1%84%86%E1%85%AE%E1%86%AB%20%E1%84%8C%E1%85%A9%E1%84%92%E1%85%AC%20V3%201%20%E1%84%8B%E1%85%A6%E1%86%AB%E1%84%90%E1%85%B5%E1%84%90%E1%85%B5%E1%84%85%E1%85%B3%E1%86%AF%20DTO%E1%84%85%E1%85%A9%20%E1%84%87%E1%85%A7%E1%86%AB%E1%84%92%E1%85%AA%E1%86%AB%20-%20%E1%84%91%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%8C%E1%85%B5%E1%86%BC%E1%84%80%20d93f4fc8ab224315b449f16fe9defa8d/Untitled%208.png)

 

쿼리가 이렇게 나온다.

![Untitled](%E1%84%8C%E1%85%AE%E1%84%86%E1%85%AE%E1%86%AB%20%E1%84%8C%E1%85%A9%E1%84%92%E1%85%AC%20V3%201%20%E1%84%8B%E1%85%A6%E1%86%AB%E1%84%90%E1%85%B5%E1%84%90%E1%85%B5%E1%84%85%E1%85%B3%E1%86%AF%20DTO%E1%84%85%E1%85%A9%20%E1%84%87%E1%85%A7%E1%86%AB%E1%84%92%E1%85%AA%E1%86%AB%20-%20%E1%84%91%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%8C%E1%85%B5%E1%86%BC%E1%84%80%20d93f4fc8ab224315b449f16fe9defa8d/Untitled%209.png)

![Untitled](%E1%84%8C%E1%85%AE%E1%84%86%E1%85%AE%E1%86%AB%20%E1%84%8C%E1%85%A9%E1%84%92%E1%85%AC%20V3%201%20%E1%84%8B%E1%85%A6%E1%86%AB%E1%84%90%E1%85%B5%E1%84%90%E1%85%B5%E1%84%85%E1%85%B3%E1%86%AF%20DTO%E1%84%85%E1%85%A9%20%E1%84%87%E1%85%A7%E1%86%AB%E1%84%92%E1%85%AA%E1%86%AB%20-%20%E1%84%91%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%8C%E1%85%B5%E1%86%BC%E1%84%80%20d93f4fc8ab224315b449f16fe9defa8d/Untitled%2010.png)

orderitem을 조회한 쿼리는 

`where orderitems0_.order_id in ( ?, ? )` 를 보면
**한번에 `inquery`로 db에 있는 userA의 `orderitems`, userB의 `orderitems`를 한번에 가져온것!!**

`default_batch_fetch_size: 100`

→ 인쿼리의 갯수를 몇개나 할것인지.

만약 이 숫자가 10, `orderItem`이 100개 있었다면 

10개까지 하고 그다음 10개까지하고 해서 쿼리가 10번 나간다.

![Untitled](%E1%84%8C%E1%85%AE%E1%84%86%E1%85%AE%E1%86%AB%20%E1%84%8C%E1%85%A9%E1%84%92%E1%85%AC%20V3%201%20%E1%84%8B%E1%85%A6%E1%86%AB%E1%84%90%E1%85%B5%E1%84%90%E1%85%B5%E1%84%85%E1%85%B3%E1%86%AF%20DTO%E1%84%85%E1%85%A9%20%E1%84%87%E1%85%A7%E1%86%AB%E1%84%92%E1%85%AA%E1%86%AB%20-%20%E1%84%91%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%8C%E1%85%B5%E1%86%BC%E1%84%80%20d93f4fc8ab224315b449f16fe9defa8d/Untitled%2011.png)

**item도 한번에 4개를 다 당겨와버린다 ⇒ 매우 편안!!**

### 여기까지만 하더라도 우리가 원하는 성능을 충분히 낼 수 있다!!

**사실 이게 쿼리 한번이면 @ToOne도 fetch 안해도 되지않아?**

→ 쿼리는 1번에 나가지만 데이터 전송량이 많다.
그 데이터를 마구가져옴. 최대한 간결하게 시작하는게 좋다.

Order입장에서 `delivery, member` 에 나가는 쿼리를 줄일 수 있기 때문에!!

## 정리

- 개별로 설정하려면 @BatchSize 를 적용하면 된다. (컬렉션은 컬렉션 필드에, 엔티티는 엔티티 클래스에 적용)
- 장점
    - 쿼리호출수가 `1+N` → `1+1`로 최적화된다.
    - 조인보다 **DB 데이터 전송량이 최적화 된다.** (`Order`와 `OrderItem`을 조인하면 `Order`가 `OrderItem` 만큼 중복해서 조회된다. **이 방법은 각각 조회하므로 전송해야할 중복 데이터가 없다**.)
    - **페치 조인 방식과 비교해서 쿼리 호출 수가 약간 증가하지만, DB 데이터 전송량이 감소한다.**
    - **컬렉션 페치 조인은 페이징이 불가능 하지만 이 방법은 페이징이 가능하다.**
- 결론
    - **ToOne 관계는 페치 조인해도 페이징에 영향을 주지 않는다. 따라서 ToOne 관계는 페치조인으로 쿼리 수를 줄이고 해결하고, 나머지는 `hibernate.default_batch_fetch_size` 로 최적화 하자.**
    

> 참고: `default_batch_fetch_size` 의 크기는 적당한 사이즈를 골라야 하는데, 100~1000 사이를 선택하는 것을 권장한다. 이 전략을 SQL IN 절을 사용하는데, 데이터베이스에 따라 IN 절 파라미터를 1000으로 제한하기도 한다. **1000으로 잡으면 한번에 1000개를 DB에서 애플리케이션에 불러오므로 DB 에 순간 부하가 증가할 수 있다.** 하지만 애플리케이션은 100이든 1000이든 결국 전체 데이터를 로딩해야 하므로 메모리 사용량이 같다. **1000으로 설정하는 것이 성능상 가장 좋지만, 결국 DB든 애플리케이션이든 순간 부하를 어디까지 견딜 수 있는지로 결정하면 된다.**
>